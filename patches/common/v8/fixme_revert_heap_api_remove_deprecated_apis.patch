From 0000000000000000000000000000000000000000 Mon Sep 17 00:00:00 2001
From: Samuel Attard <sattard@slack-corp.com>
Date: Thu, 21 Mar 2019 22:29:55 -0700
Subject: fixme: Revert "[heap,api] Remove deprecated APIs"

This reverts commit f4b860d9b81956fb9d6815932522f4043fef56fa.

This commit removes deprecated APIs that nan relies on, temporarily
reverting but we need to solve this with nan upstream

diff --git a/include/v8-internal.h b/include/v8-internal.h
index fe2ce67e0df04e58502d73ca5ac81a86ee001494..ed110be42bf4d7ab47bee480d8dbbfe547fbc423 100644
--- a/include/v8-internal.h
+++ b/include/v8-internal.h
@@ -174,6 +174,7 @@ class Internals {
   static const int kNodeStateMask = 0x7;
   static const int kNodeStateIsWeakValue = 2;
   static const int kNodeStateIsPendingValue = 3;
+  static const int kNodeStateIsNearDeathValue = 4;
   static const int kNodeIsIndependentShift = 3;
   static const int kNodeIsActiveShift = 4;
 
diff --git a/include/v8.h b/include/v8.h
index 0adb423592e7040f60a2bb8f1b9429228341838b..2f983b34ceb2ae9a98fac682de66336d9d016d16 100644
--- a/include/v8.h
+++ b/include/v8.h
@@ -576,6 +576,10 @@ template <class T> class PersistentBase {
 
   V8_DEPRECATED("See MarkIndependent.", V8_INLINE bool IsIndependent() const);
 
+  /** Checks if the handle holds the only reference to an object. */
+  V8_DEPRECATED("Garbage collection internal state should not be relied on.",
+                V8_INLINE bool IsNearDeath() const);
+
   /** Returns true if the handle's reference is weak.  */
   V8_INLINE bool IsWeak() const;
 
@@ -8530,6 +8534,17 @@ class V8_EXPORT Isolate {
    */
   void VisitHandlesWithClassIds(PersistentHandleVisitor* visitor);
 
+  /**
+   * Iterates through all the persistent handles in the current isolate's heap
+   * that have class_ids and are candidates to be marked as partially dependent
+   * handles. This will visit handles to young objects created since the last
+   * garbage collection but is free to visit an arbitrary superset of these
+   * objects.
+   */
+  V8_DEPRECATED(
+      "Use VisitHandlesWithClassIds",
+      void VisitHandlesForPartialDependence(PersistentHandleVisitor* visitor));
+
   /**
    * Iterates through all the persistent handles in the current isolate's heap
    * that have class_ids and are weak to be marked as inactive if there is no
@@ -9807,6 +9822,17 @@ bool PersistentBase<T>::IsIndependent() const {
                         I::kNodeIsIndependentShift);
 }
 
+template <class T>
+bool PersistentBase<T>::IsNearDeath() const {
+  typedef internal::Internals I;
+  if (this->IsEmpty()) return false;
+  uint8_t node_state =
+      I::GetNodeState(reinterpret_cast<internal::Address*>(this->val_));
+  return node_state == I::kNodeStateIsNearDeathValue ||
+      node_state == I::kNodeStateIsPendingValue;
+}
+
+
 template <class T>
 bool PersistentBase<T>::IsWeak() const {
   typedef internal::Internals I;
diff --git a/src/api/api.cc b/src/api/api.cc
index 693872f22581066cbc33d0b87fed6e3e40102e6e..d0c0ae17edb94e88ec48828e115ecd762ef0674c 100644
--- a/src/api/api.cc
+++ b/src/api/api.cc
@@ -8628,6 +8628,15 @@ void Isolate::VisitHandlesWithClassIds(PersistentHandleVisitor* visitor) {
   isolate->global_handles()->IterateAllRootsWithClassIds(visitor);
 }
 
+
+void Isolate::VisitHandlesForPartialDependence(
+    PersistentHandleVisitor* visitor) {
+  i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);
+  i::DisallowHeapAllocation no_allocation;
+  isolate->global_handles()->IterateAllYoungRootsWithClassIds(visitor);
+}
+
+
 void Isolate::VisitWeakHandles(PersistentHandleVisitor* visitor) {
   i::Isolate* isolate = reinterpret_cast<i::Isolate*>(this);
   i::DisallowHeapAllocation no_allocation;
diff --git a/src/global-handles.cc b/src/global-handles.cc
index ef0181d5913f5e89baa6b16b98d5568943e34d01..02561dd2896ed459de9000cc28493fd2ca57de1a 100644
--- a/src/global-handles.cc
+++ b/src/global-handles.cc
@@ -380,6 +380,7 @@ class GlobalHandles::Node final : public NodeBase<GlobalHandles::Node> {
                   Internals::kNodeStateMask);
     STATIC_ASSERT(WEAK == Internals::kNodeStateIsWeakValue);
     STATIC_ASSERT(PENDING == Internals::kNodeStateIsPendingValue);
+    STATIC_ASSERT(NEAR_DEATH == Internals::kNodeStateIsNearDeathValue);
     STATIC_ASSERT(static_cast<int>(IsIndependent::kShift) ==
                   Internals::kNodeIsIndependentShift);
     STATIC_ASSERT(static_cast<int>(IsActive::kShift) ==
@@ -427,6 +428,11 @@ class GlobalHandles::Node final : public NodeBase<GlobalHandles::Node> {
     flags_ = NodeWeaknessType::update(flags_, weakness_type);
   }
 
+  bool IsNearDeath() const {
+    // Check for PENDING to ensure correct answer when processing callbacks.
+    return state() == PENDING || state() == NEAR_DEATH;
+  }
+
   bool IsWeak() const { return state() == WEAK; }
 
   bool IsInUse() const { return state() != FREE; }
@@ -814,6 +820,10 @@ void GlobalHandles::AnnotateStrongRetainer(Address* location,
   Node::FromLocation(location)->AnnotateStrongRetainer(label);
 }
 
+bool GlobalHandles::IsNearDeath(Address* location) {
+  return Node::FromLocation(location)->IsNearDeath();
+}
+
 bool GlobalHandles::IsWeak(Address* location) {
   return Node::FromLocation(location)->IsWeak();
 }
diff --git a/src/global-handles.h b/src/global-handles.h
index 8d5bae1491d34311f9559cc70c68498416a326af..e7a0b834d8a70cb368499222687c5bca5b5b4560 100644
--- a/src/global-handles.h
+++ b/src/global-handles.h
@@ -73,6 +73,9 @@ class V8_EXPORT_PRIVATE GlobalHandles final {
   // Clear the weakness of a global handle.
   static void* ClearWeakness(Address* location);
 
+  // Tells whether global handle is near death.
+  static bool IsNearDeath(Address* location);
+
   // Tells whether global handle is weak.
   static bool IsWeak(Address* location);
 
diff --git a/test/cctest/heap/test-heap.cc b/test/cctest/heap/test-heap.cc
index f67ee369ba3b9954f8af431bea93ecc3933b4e26..4b1019c4f4e0cd04662dd2fdc850dc4ef9256a45 100644
--- a/test/cctest/heap/test-heap.cc
+++ b/test/cctest/heap/test-heap.cc
@@ -527,9 +527,14 @@ TEST(WeakGlobalHandlesScavenge) {
 
   // Scavenge treats weak pointers as normal roots.
   CcTest::CollectGarbage(NEW_SPACE);
+
   CHECK((*h1)->IsString());
   CHECK((*h2)->IsHeapNumber());
+
   CHECK(!WeakPointerCleared);
+  CHECK(!global_handles->IsNearDeath(h2.location()));
+  CHECK(!global_handles->IsNearDeath(h1.location()));
+
   GlobalHandles::Destroy(h1.location());
   GlobalHandles::Destroy(h2.location());
 }
@@ -567,8 +572,11 @@ TEST(WeakGlobalUnmodifiedApiHandlesScavenge) {
       &TestWeakGlobalHandleCallback, v8::WeakCallbackType::kParameter);
 
   CcTest::CollectGarbage(NEW_SPACE);
+
   CHECK((*h1)->IsHeapNumber());
   CHECK(WeakPointerCleared);
+  CHECK(!global_handles->IsNearDeath(h1.location()));
+
   GlobalHandles::Destroy(h1.location());
 }
 
@@ -605,7 +613,10 @@ TEST(WeakGlobalApiHandleModifiedMapScavenge) {
       &TestWeakGlobalHandleCallback, v8::WeakCallbackType::kParameter);
 
   CcTest::CollectGarbage(NEW_SPACE);
+
   CHECK(!WeakPointerCleared);
+  CHECK(!global_handles->IsNearDeath(h1.location()));
+
   GlobalHandles::Destroy(h1.location());
 }
 
@@ -646,7 +657,10 @@ TEST(WeakGlobalApiHandleWithElementsScavenge) {
       &TestWeakGlobalHandleCallback, v8::WeakCallbackType::kParameter);
 
   CcTest::CollectGarbage(NEW_SPACE);
+
   CHECK(!WeakPointerCleared);
+  CHECK(!global_handles->IsNearDeath(h1.location()));
+
   GlobalHandles::Destroy(h1.location());
 }
 
@@ -681,11 +695,17 @@ TEST(WeakGlobalHandlesMark) {
   GlobalHandles::MakeWeak(
       h2.location(), reinterpret_cast<void*>(&handle_and_id),
       &TestWeakGlobalHandleCallback, v8::WeakCallbackType::kParameter);
+  CHECK(!GlobalHandles::IsNearDeath(h1.location()));
+  CHECK(!GlobalHandles::IsNearDeath(h2.location()));
 
   // Incremental marking potentially marked handles before they turned weak.
   CcTest::CollectAllGarbage();
+
   CHECK((*h1)->IsString());
+
   CHECK(WeakPointerCleared);
+  CHECK(!GlobalHandles::IsNearDeath(h1.location()));
+
   GlobalHandles::Destroy(h1.location());
 }
 
diff --git a/test/cctest/test-api.cc b/test/cctest/test-api.cc
index 8db9adcf509b4dcdab08f87dbe9148038fdefda3..5333cec913d249c331e12d267fa76f7e08f16b24 100644
--- a/test/cctest/test-api.cc
+++ b/test/cctest/test-api.cc
@@ -19812,6 +19812,43 @@ TEST(WrapperClassId) {
   object.Reset();
 }
 
+
+TEST(PersistentHandleInNewSpaceVisitor) {
+  LocalContext context;
+  v8::Isolate* isolate = context->GetIsolate();
+  v8::HandleScope scope(isolate);
+  v8::Persistent<v8::Object> object1(isolate, v8::Object::New(isolate));
+  CHECK_EQ(0, object1.WrapperClassId());
+  object1.SetWrapperClassId(42);
+  CHECK_EQ(42, object1.WrapperClassId());
+
+  CcTest::CollectAllGarbage();
+  CcTest::CollectAllGarbage();
+
+  v8::Persistent<v8::Object> object2(isolate, v8::Object::New(isolate));
+  CHECK_EQ(0, object2.WrapperClassId());
+  object2.SetWrapperClassId(42);
+  CHECK_EQ(42, object2.WrapperClassId());
+
+  Visitor42 visitor(&object2);
+#if __clang__
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wdeprecated"
+#endif
+  // VisitHandlesForPartialDependence is marked deprecated. This test will be
+  // removed with the API method.
+  isolate->VisitHandlesForPartialDependence(&visitor);
+#if __clang__
+#pragma clang diagnostic pop
+#endif
+
+  CHECK_EQ(1, visitor.counter_);
+
+  object1.Reset();
+  object2.Reset();
+}
+
+
 TEST(RegExp) {
   LocalContext context;
   v8::HandleScope scope(context->GetIsolate());
